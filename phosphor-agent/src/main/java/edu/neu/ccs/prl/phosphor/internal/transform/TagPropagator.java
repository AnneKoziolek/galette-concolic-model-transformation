package edu.neu.ccs.prl.phosphor.internal.transform;

import edu.neu.ccs.prl.phosphor.internal.runtime.Handle;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.MethodNode;

class TagPropagator extends MethodVisitor {
    private final ShadowLocals shadowLocals;

    TagPropagator(MethodVisitor mv, MethodNode original, boolean isShadow) {
        this(new ShadowLocals(mv, original, isShadow));
    }

    private TagPropagator(ShadowLocals shadowLocals) {
        super(PhosphorTransformer.ASM_VERSION, shadowLocals);
        if (shadowLocals == null) {
            throw new NullPointerException();
        }
        this.shadowLocals = shadowLocals;
    }

    @Override
    public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
        if (isGetCallerClass(owner, name, descriptor)) {
            // Call the original method
            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
            // [Class]
            shadowLocals.loadPhosphorFrame();
            // [Class Frame]
            super.visitInsn(Opcodes.SWAP);
            // [Frame Class]
            Handle.FRAME_GET_CALLER.accept(mv);
            // [Class]
        } else if (!isIgnoredMethod(owner, name)) {
            descriptor = ShadowMethodCreator.getShadowMethodDescriptor(descriptor);
            shadowLocals.loadPhosphorFrame();
            Handle.FRAME_CREATE_FOR_CALL.accept(mv);
            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
        } else {
            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
        }
    }

    private static boolean isGetCallerClass(String owner, String name, String descriptor) {
        // The result of getCallerClass depends on the caller, so we cannot use the native wrapper without changing the
        // caller
        if (name.equals("getCallerClass") && "()Ljava/lang/Class;".equals(descriptor)) {
            return owner.equals("jdk/internal/reflect/Reflection") || owner.equals("sun/reflect/Reflection");
        }
        return false;
    }

    private static boolean isIgnoredMethod(String owner, String name) {
        if (Configuration.isInternalTaintingClass(owner)) {
            return false;
        }
        // We cannot add shadow methods to Object or arrays
        if (owner.equals("java/lang/Object") || owner.startsWith("[")) {
            return true;
        }
        // Shadows are not created for classes explicitly from Phosphor instrumentation
        if (PhosphorTransformer.isExcluded(owner)) {
            return true;
        }
        // These classes are regenerated by the "system modules" jlink plugin
        if (owner.startsWith("jdk/internal/module/SystemModules")) {
            return true;
        }
        // Needed for compatability with the JProfiler agent
        // TODO check if needed
        if (owner.startsWith("com/jprofiler")) {
            return true;
        }
        // TODO figure out why these are needed and if there are other Handles that need to listed
        // TODO check if needed
        if (owner.equals("java/lang/invoke/MethodHandle")) {
            return true;
        }
        if (owner.equals("java/lang/invoke/BoundMethodHandle")) {
            return true;
        }
        if (owner.equals("java/lang/invoke/VarHandle")) {
            return true;
        }
        // A shadow was not created for the original method
        return !ShadowMethodCreator.shouldShadow(name);
    }
}
