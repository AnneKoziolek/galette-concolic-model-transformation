How to store taint tags for fields

1. Create a shadow class for each class containing a shadow field for each field in the original class. Maintain a map from instances to shadows.
For classes that are statically instrumented you can generate the shadow and pack it into either
a) the runtime image for classes from Java 9+ installations
b) a bootstrap jar for classes from Java 8 installations
c) the original jar for classes from application code
However, it is difficult to handle dynamically instrumented classes
You cannot use Unsafe.defineClass because the parent of the class being instrumented may not have been loaded yet.
Therefore, the parent/interface shadows may not have been defined.
I tried to add code to <clinit> to define the shadow class by embedding the raw bytes into the bytecode for <clinit> and then adding a call to define class.
This works okay but I think will problematic in the long run because I believe that you can reference the static fields of a class before it is initialized.
I think I encountered this situation when working on xebec.
Instrumentation#appendToBootstrapClassLoaderSearch or Instrumentation#appendToSystemClassLoaderSearch could be used in theory but classes are uniquely defined per class loaded so we would need to append to the class loader used to load the original class.
This has implications for garbage collection and also could cause issues if two different classes with same name are loaded in different loaders.

add a static method to the class 
call before all field accesses?
initializeShadow() {
	// For Java 11+ you could do a dynamic constant
	// For Java 5+ double-check locking with volatile
	// Probably easiest to do ACC_SYNCHRONIZED? Can this deadlock in some way?
	// It may be best to have some sort of other object you can synchronize on
	// I think you could technically use a dynamic constant in Java 11+ classes
	if(!initialized) {
		initialized = true; // need to make thread safe
		// define shadow class in class loader for original class
	}
}
Instrument ClassLoader#loadClass or ClassLoader#findClass?
if loadClass fails and the name has the Phosphor suffix then delegate to a byte-array backed class loader?
shadow class loaders?

2. Add a shadow field for each field in the original class to the class itself.
The JVM uses hard-coded offsets to access fields in certain classes.
If you add the shadow fields after all other fields have been visited, I believe that this will always preserve the original offset of instance fields and
perserve the offset of static fields if there are no instance shadow fields.
So, there is only an issue if the class contains both instance and static fields and the JVM uses a hard-coded offset for a static field.
Based on empirical tests and inspection of the source code, there are only three classes for temurin 8, 11, 17, and 21 for which this is the case:
java/lang/Integer, java/lang/Long, java/lang/ref/SoftReference.

I am not sure if this is overly "fragile".
-------------------------------------------------------------------------------------------------------------------------
How to pass tags between method calls

1. Add a "frame" parameter to all methods
pros: @HotSpotIntrinsicCandidate
class loading and other method calls not signaled by the bytecode
implicitly thrown exceptions, native code
any methods you are not instrumenting

2. Store a "frame" parameter on a field added to java/lang/Thread
pros: CallerSensitive, do not need to "hide" added methods

Could disable instrinsics instead but you must list all intrinsics manually:
java -XX:+UnlockDiagnosticVMOptions  -XX:DisableIntrinsic=_equals,_hashCode,...,

java -XX:+UnlockDiagnosticVMOptions  -XX:+PrintFlagsFinal -version
